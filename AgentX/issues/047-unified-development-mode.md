# Unified Development Mode: Code Review + BDD

## 概述

这是 AgentX 项目的统一开发协作模式，结合了 **Code Review 协作** 和 **BDD（行为驱动开发）**。

**核心理念**：

- 测试不是"事后补"的，而是开发过程中自然产出的
- Feature 文件 = 需求文档 + 验收标准 + 自动化测试
- 问题充分讨论后再动手，避免返工

---

## 角色定义

| 角色          | 担任者 | 职责                              |
| ------------- | ------ | --------------------------------- |
| **Reviewer**  | Claude | 审查代码/设计，发现问题，提出疑问 |
| **Architect** | 用户   | 解答问题，做决策，确定方案        |
| **Developer** | Claude | 实现代码，编写测试                |

---

## 开发流程

```
┌─────────────────────────────────────────────────────────────┐
│  Phase 1: 需求澄清 (Code Review Mode)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Reviewer 阅读相关代码/文档                              │
│           ↓                                                 │
│  2. 发现问题，提出疑问（使用问题格式）                      │
│           ↓                                                 │
│  3. Architect 解答，做出决策                                │
│           ↓                                                 │
│  4. Reviewer 确认理解，追问直到清晰                         │
│           ↓                                                 │
│  5. 方案确定，进入 Phase 2                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  Phase 2: 行为定义 (BDD)                                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 编写 .feature 文件描述期望行为                          │
│           ↓                                                 │
│  2. Architect 确认 feature 正确                             │
│           ↓                                                 │
│  3. 实现 step definitions（如需要）                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│  Phase 3: 实现 (TDD)                                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 运行测试（预期失败）                                    │
│           ↓                                                 │
│  2. 实现代码                                                │
│           ↓                                                 │
│  3. 运行测试（通过 = 完成）                                 │
│           ↓                                                 │
│  4. 重构（保持测试通过）                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Phase 1: Code Review 模式

### 问题分类

| 类型     | 描述                     | 示例                              |
| -------- | ------------------------ | --------------------------------- |
| **盲点** | 缺失的逻辑，没想到的场景 | "断线重连时 cursor 怎么恢复？"    |
| **架构** | 职责模糊，依赖混乱       | "Queue 和 Network 谁负责路由？"   |
| **功能** | 接口定义了但没实现       | "handleConnection 方法未实现"     |
| **坑**   | 潜在 bug，边界条件       | "多 tab 共享 localStorage 会冲突" |

### 提问格式

```markdown
**问题 N：[简短标题]**

**代码位置**：`path/to/file.ts:line`

**问题描述**：
[具体描述问题是什么]

**涉及的关键点**：

1. 点 1
2. 点 2
3. 点 3

**状态**：待解答
```

### 原则

1. **问题驱动** - 带着批判性思维找问题，不是漫无目的读代码
2. **不轻易动手** - 方案没确定之前不执行
3. **持续追问** - 一个问题可以追问多轮，直到完全理解
4. **收敛机制** - 通过 API 边界来收紧问题范围

---

## Phase 2: BDD 模式

### Feature 文件结构

```gherkin
@tag
Feature: 功能名称
  功能描述（一两句话说明这个功能是什么）

  Background:
    Given 前置条件（所有场景共享）

  @scenario-tag
  Scenario: 场景名称
    Given 前置条件
    When 执行动作
    Then 期望结果
    And 更多期望
```

### 文件组织

```
bdd/
├── features/
│   ├── queue/
│   │   ├── subscribe.feature      # 订阅功能
│   │   ├── ack.feature            # ACK 功能
│   │   └── reconnect.feature      # 断线重连
│   ├── agentx/
│   │   ├── local-mode.feature     # 本地模式
│   │   └── remote-mode.feature    # 远程模式
│   └── ...
├── steps/
│   ├── queue.steps.ts
│   ├── agentx.steps.ts
│   └── ...
└── world.ts                        # 共享上下文
```

### 编写原则

1. **业务语言** - 用业务术语，不用技术细节
2. **独立场景** - 每个 Scenario 独立，不依赖执行顺序
3. **声明式** - 描述"什么"，不描述"怎么做"
4. **可读性** - 非技术人员也能理解

### 示例

```gherkin
@queue @subscribe
Feature: Queue 订阅
  客户端可以订阅 topic，接收实时消息，断线后能恢复。

  Background:
    Given Queue 服务已启动
    And 客户端已连接

  Scenario: 客户端订阅 topic 后收到新消息
    Given topic "session-123" 存在
    When 客户端订阅 "session-123"
    And 服务端发送消息 "hello" 到 "session-123"
    Then 客户端应该收到消息 "hello"

  Scenario: 客户端断线重连后恢复消息
    Given 客户端订阅了 "session-123"
    And 客户端消费到 cursor "c-100"
    When 客户端断开连接
    And 服务端发送消息 "missed" 到 "session-123"
    And 客户端重新连接
    Then 客户端应该收到消息 "missed"
```

---

## Phase 3: 实现

### 流程

```bash
# 1. 运行测试（预期失败）
bun bdd --tags @queue

# 2. 实现代码
# ... 编写实现 ...

# 3. 运行测试（通过）
bun bdd --tags @queue

# 4. 运行全部测试确保没有破坏其他功能
bun test
```

### 原则

1. **最小实现** - 只实现让测试通过的代码
2. **不过度设计** - 不为假想的未来需求写代码
3. **持续重构** - 测试通过后可以重构，保持测试绿色

---

## 快速参考

### 开发新功能

```
1. Code Review: 讨论需求，确定方案
2. BDD: 写 .feature 文件
3. 实现: 让测试通过
4. 提交
```

### 修复 Bug

```
1. 写一个失败的测试用例（复现 bug）
2. 修复代码
3. 测试通过 = bug 已修复
4. 提交
```

### 重构

```
1. 确保现有测试全部通过
2. 重构代码
3. 运行测试，保持绿色
4. 提交
```

---

## 命令速查

```bash
# 运行所有 BDD 测试
bun bdd

# 运行指定 tag 的测试
bun bdd --tags @queue
bun bdd --tags "@queue and @subscribe"
bun bdd --tags "not @pending"

# 运行单元测试
bun test
bun --filter @agentxjs/queue test

# 类型检查
bun typecheck
```

---

## 何时使用这个模式

| 场景       | 是否使用                          |
| ---------- | --------------------------------- |
| 新功能开发 | ✅ 完整流程                       |
| Bug 修复   | ✅ 简化版（写测试 → 修复 → 通过） |
| 重构       | ✅ 确保测试通过                   |
| 探索性调研 | ❌ 不需要，直接探索               |
| 紧急修复   | ⚠️ 可跳过 BDD，但事后补测试       |

---

## 相关文件

- `bdd/` - BDD 测试目录
- `bdd/cucumber.js` - Cucumber 配置
- `bdd/features/` - Feature 文件
- `bdd/steps/` - Step 实现
- `bdd/world.ts` - 共享上下文
